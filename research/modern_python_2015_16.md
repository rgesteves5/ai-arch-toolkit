# Modern Python beyond the basics: what's changed in 2025

**The Python ecosystem is undergoing its most significant tooling consolidation in a decade.** Astral's Rust-powered trio — uv, ruff, and ty — has reshaped how Python projects are built, linted, and type-checked, while Python 3.12–3.14 introduced language-level changes that alter common coding patterns. The practical effect: a new Python project started in 2025 looks fundamentally different from one started in 2022. This report covers the ten areas you identified as gaps, focusing on what's widely adopted and practically recommended rather than experimental.

---

## The Astral-led tooling revolution has redefined the default stack

The most consequential shift in the Python ecosystem is the emergence of **uv** as a near-universal replacement for pip, pip-tools, virtualenv, pipx, and pyenv — all in a single Rust binary that runs **8–115× faster** than pip depending on cache state. As of early 2026, uv has accumulated **~36,100 GitHub stars** and handles roughly **13% of all PyPI package downloads**. It manages dependency resolution, virtual environments, Python version installation, tool execution (via `uvx`), building, publishing, lockfiles, and workspace-based monorepos. The Wagtail project reports **66% uv vs. 34% pip** in their CI usage, a telling adoption signal.

In the packaging tool competition, **uv is the clear momentum winner** over Poetry (~31K stars, mature but slower by orders of magnitude), PDM (~7.5K stars, standards-focused), and Hatch (~6K stars, no lockfile support yet). Poetry 2.0 (January 2025) finally adopted the `[project]` table (PEP 621), aligning with the standard that uv, PDM, and Hatch already supported. For teams already on Poetry, staying is reasonable — but new projects increasingly default to uv. The PyPA itself doesn't endorse a specific project manager but has standardized on `pyproject.toml` with PEP 621 metadata as the universal configuration format.

**Ruff** has effectively won the linting and formatting wars. With **800+ lint rules** implemented natively in Rust, it replaces Flake8, isort, pyupgrade, autoflake, and pydocstyle. Its formatter achieves **>99.9% compatibility with Black** while running **30× faster**. Projects like FastAPI, pandas, Django, and Pydantic have switched. Pylint retains an edge in deep cross-file analysis (~200 rules Ruff doesn't cover), but many teams now treat ruff plus a type checker as a sufficient replacement. Black itself remains maintained, but `ruff format` is the recommended choice for new projects.

The type checker landscape is splitting into an exciting four-way race. **Mypy** retains the largest CI installed base (inertia, plugin ecosystem for Django/SQLAlchemy). **Pyright** dominates IDE usage through VS Code's Pylance extension, running **3–5× faster** than mypy and checking unannotated code by default. **ty** (Astral's Rust-based checker, beta December 2025) benchmarks at **10–60× faster** than both — recomputing PyTorch type information in 4.7ms versus Pyright's 386ms. Meta's **Pyrefly** entered beta in November 2025, processing **1.85 million lines per second** on their infrastructure. The practical recommendation: use Pyright/Pylance in your editor for instant feedback, run mypy or pyright in CI as the authoritative gate, and watch ty closely for a 2026 stable release. **basedpyright** (~2,468 stars) offers stricter defaults and works on VSCodium for developers wanting more aggressive type checking.

The emerging "default stack" for a new Python project: **uv + ruff + pytest + pyright** (or ty), with `pyproject.toml` as the single configuration file.

---

## Python 3.12–3.14 introduced patterns worth adopting now

**Python 3.12** (October 2023) delivered the most impactful typing change since type hints themselves. **PEP 695** introduced compact generic syntax — `class Stack[T]` replaces the verbose `TypeVar('T')` / `Generic[T]` dance, and `type NumberType = int | float` replaces `TypeAlias`. These are lazily evaluated and locally scoped, eliminating a class of subtle bugs. PEP 701 lifted f-string restrictions: you can now reuse quotes (`f"{'hello'}"`) and nest f-strings freely, with the tokenizer running **up to 64% faster**. The `@typing.override()` decorator (PEP 698) catches method override mistakes when base classes change — a small addition with outsized value in large codebases.

**Python 3.13** (October 2024) shipped the first experimental **free-threaded build** (`python3.13t`) — CPython without the GIL. The initial implementation carried a **~40% single-threaded performance penalty** and required C extensions to explicitly declare free-threading support. More practically, 3.13 added type parameter defaults (`class Foo[T = int]`), a completely rewritten interactive REPL with multiline editing and color support, and removed several legacy stdlib modules per the "dead batteries" cleanup (PEP 594).

**Python 3.14** (October 2025) is where things get transformative. **PEP 649/749 introduced deferred evaluation of annotations** — annotations are no longer evaluated at class/function definition time, eliminating the need for `from __future__ import annotations` (now deprecated) and making forward references work without string quoting. **PEP 750 added template string literals** (`t"Hello {name}"`) that return a `Template` object instead of a string, enabling safe HTML templating, structured logging, and parameterized SQL. **PEP 734 brought multiple interpreters** to the stdlib via `concurrent.interpreters`, each with its own GIL — more efficient than multiprocessing since they share a process. Free-threaded Python moved to officially supported status (PEP 779), with the single-threaded penalty reduced to **~5–10%**.

**Pattern matching** (PEP 634, Python 3.10) adoption remains gradual. It shines for AST processing, command dispatching, and destructuring complex data, but most codebases find `if/elif` or dictionary lookup sufficient for simple cases. **Protocol** has gained significant traction as Python's answer to structural subtyping — preferred over ABCs for duck-typing scenarios. **PEP 723 inline script metadata** deserves special mention: embedding `# /// script` headers with dependencies in single-file scripts lets `uv run script.py` auto-create an isolated environment in under a second, eliminating the need for `requirements.txt` in scripting contexts.

---

## Pre-commit and CI/CD pipelines have converged on a clean pattern

Modern pre-commit configurations have simplified dramatically thanks to ruff. Where teams previously juggled five or six hooks (Black, Flake8, isort, pyupgrade, autoflake, bandit), a typical 2025 `.pre-commit-config.yaml` needs just three repositories: `pre-commit/pre-commit-hooks` for generic file checks (trailing whitespace, YAML validation, large file detection, private key detection), `astral-sh/ruff-pre-commit` for Python linting and formatting, and optionally `pre-commit/mirrors-mypy` for type checking. The critical ordering rule: **ruff-check with `--fix` must run before ruff-format**, since auto-fixes may produce code needing reformatting. Store all ruff/mypy configuration in `pyproject.toml` rather than hook `args:` to ensure consistency across pre-commit, CI, and IDE. Gitleaks has become the standard secrets-scanning hook, replacing ad-hoc approaches. The `pre-commit.ci` service auto-runs hooks on PRs and commits fixes, used by projects like FastAPI via `pre-commit-ci/lite-action`.

GitHub Actions CI pipelines follow a standard multi-job structure: **lint → type-check → test (matrix) → build → publish**. Key conventions include running lint and type-check against one Python version (latest), while matrix-testing against **Python 3.10 through 3.13** (3.8 and 3.9 are EOL). `actions/setup-python@v5` now includes built-in pip caching, eliminating manual cache configuration. Ruff's `--output-format=github` flag enables inline PR annotations. For coverage, **pytest-cov** generates XML reports uploaded via `codecov/codecov-action@v5`, with `[tool.coverage.run] branch = true` and `report.fail_under` in `pyproject.toml` to enforce minimums.

**PyPI Trusted Publishing** is the current best practice for package releases — no API tokens needed. It uses OpenID Connect between GitHub Actions and PyPI, with `pypa/gh-action-pypi-publish@release/v1` handling the flow. Packages get **Sigstore-signed digital attestations** automatically. Configure a GitHub Environment (e.g., `pypi`) with manual approval for production releases. For dependency updates, **Dependabot** handles simple cases (it now supports `package-ecosystem: "uv"`), while **Renovate** offers far more configurability — grouping, automerge, monorepo support, and scheduling. Some teams use both: Dependabot for security alerts, Renovate for regular updates.

---

## Structured logging and documentation tooling are both in transition

The logging recommendation has crystallized: **use structlog wrapping stdlib logging for production services**. Structlog's core concept — event dictionaries processed through a processor chain — produces machine-parseable JSON output that log aggregation tools (ELK, Datadog, SigNoz) can query by `user_id`, `request_id`, or any other field. The integration pattern routes structlog through stdlib's logging infrastructure via `structlog.stdlib.ProcessorFormatter`, which means third-party library logs (which use stdlib) get formatted consistently alongside your application logs. Context binding (`log.bind(user_id=123)`) and `contextvars` integration make correlation IDs trivial — call `structlog.contextvars.bind_contextvars(request_id=str(uuid4()))` at request entry and every subsequent log call includes it automatically.

**Loguru** (~21K GitHub stars, ~55M monthly downloads) remains popular for scripts and small projects thanks to its zero-config simplicity, but its global singleton logger and message-template orientation make it less suitable for production structured logging. The most common logging mistake in Python is **eager string formatting**: `logger.debug(f"Processing {expensive_obj}")` evaluates the f-string even when DEBUG is disabled. Use `logger.info("User %s", name)` with stdlib or key-value pairs with structlog. Production systems should log to **stdout in JSON format** per 12-factor app principles, letting the execution environment (Docker, Kubernetes) handle collection and routing.

On the documentation front, a seismic shift occurred in **November 2025 when Material for MkDocs entered maintenance mode**. Creator Martin Donath announced version 9.7.0 as the final feature release, sunsetting it in favor of **Zensical** — a next-generation static site generator built from scratch by the same team. Material for MkDocs (~25K GitHub stars) had been used by AWS, Microsoft, Google, Netflix, OpenAI, FastAPI, and Pydantic, so this transition affects thousands of projects. Sphinx remains the safest long-term bet for complex API documentation with cross-referencing, especially for scientific projects. For docstrings, **Google style is the most widely adopted**, with a critical modern consensus: **omit type information from docstrings when PEP 484 annotations are present** — docstrings should describe semantics (what a parameter means, constraints, side effects) while types come from annotations that type checkers actually validate.

---

## Security requires layered defenses across the pipeline

Python security conventions follow a layered model. At the **secrets management** layer, use `python-dotenv` for local development (always add `.env` to `.gitignore`, commit `.env.example` with placeholders), GitHub Actions `${{ secrets.SECRET_NAME }}` for CI, and cloud secret managers (AWS Secrets Manager, HashiCorp Vault) for production. `pydantic-settings` can unify reading from environment variables, `.env` files, and cloud providers.

For **dependency scanning**, `pip-audit` (PyPA-maintained) is the lightweight recommended tool, scanning installed packages against known CVE databases. Layer it with GitHub Dependabot security alerts for automatic vulnerability notifications. **Bandit** remains the standard Python SAST tool with 68 security checks, though Ruff now implements many Bandit rules via the `S` rule prefix, catching `eval()`, `exec()`, hardcoded passwords, and weak hashing during normal linting. **Semgrep** provides more advanced pattern-based analysis — GitLab migrated their entire SAST pipeline from Bandit to Semgrep starting at version 14.0.

**Supply chain security** received a standards-level boost with **PEP 751** (accepted March 2025), which defines `pylock.toml` — a standardized, TOML-based lock file format that **requires file hashes** for all packages by default. Until `pylock.toml` is widely adopted, use uv's lockfile with hash verification. A practical uv feature for supply chain safety: `--exclude-newer "1 week"` delays adoption of brand-new packages, allowing time for malicious uploads to be detected and yanked. The recommended security pipeline order: Gitleaks (secrets) → Ruff S rules (basic security) → Bandit (deep Python SAST) → Semgrep (advanced patterns) → pip-audit (dependencies). Never use `pickle` to deserialize untrusted data, never use `subprocess` with `shell=True` on user input, and always use parameterized queries for SQL.

---

## Monorepos are increasingly viable thanks to uv workspaces

Python monorepos have moved from enterprise-only (Google, Meta, Dropbox using Bazel/Pants) to accessible for mid-size teams, primarily due to **uv workspaces**. Inspired by Rust's Cargo workspaces, uv lets you define workspace members via glob patterns in a root `pyproject.toml`, share a single `uv.lock` across all packages, and reference internal packages via `tool.uv.sources`. Commands like `uv sync`, `uv run --package <name>`, and `uv lock` operate workspace-wide. Notable open-source Python monorepos include **LangChain** (core, community, partners), **Dagster**, and **Home Assistant**.

For complex monorepos needing fine-grained build caching and dependency inference, **Pants** is the strongest Python-specific choice — originally from Twitter, it infers dependencies from source code with minimal BUILD file boilerplate. Bazel (Google) scales to enormous polyglot repositories but requires more infrastructure investment. Nx and Turborepo lack first-class Python support and aren't recommended. The **Una** CLI tool fills uv workspaces' main gap — it injects local dependencies into wheels at build time, enabling proper packaging and publishing from monorepo structures. Key tradeoff: monorepos offer atomic cross-package refactoring and unified configuration, but introduce CI complexity (smart change detection needed) and Docker layer-caching challenges.

---

## Ten anti-patterns that still trip up experienced Python developers

Beyond the classics (mutable default arguments, bare `except` clauses, star imports), several modern anti-patterns deserve attention. **Overusing Pydantic for internal data passing** is a growing performance concern — Pydantic is **6.5× slower** than dataclasses for instance creation and should be reserved for validation boundaries (API requests, external data). Use `@dataclass(frozen=True, slots=True)` for internal domain objects, adding `kw_only=True` for classes with three or more fields.

**Blocking calls inside async functions** remains the most common async anti-pattern: using `requests.get()` instead of `httpx.AsyncClient` freezes the event loop. Equally problematic is sequential awaiting (`a = await fetch_a(); b = await fetch_b()`) when `asyncio.gather(fetch_a(), fetch_b())` would run concurrently. Making functions async when they perform no I/O and contain no awaits wastes overhead for zero benefit.

**Not adopting modern tooling** is itself becoming an anti-pattern. Projects still managing dependencies with raw `pip` + `requirements.txt` + manual `virtualenv` when `uv` handles all of this faster and more reliably are leaving significant developer productivity on the table. Similarly, ignoring `frozen=True` and `slots=True` on dataclasses misses easy wins for immutability and memory efficiency. Not using PEP 723 inline script metadata for standalone scripts makes them harder to reproduce and share. And while pattern matching is powerful for ASTs and command dispatching, using `match/case` for simple value lookups where a dictionary would suffice is an emerging overuse pattern — not everything needs to be a structural match.

## Conclusion

The Python ecosystem in 2025–2026 has reached an inflection point driven by three forces: Astral's Rust-powered toolchain consolidating fragmented workflows into uv + ruff + ty, Python 3.12–3.14 delivering meaningful language-level improvements (PEP 695 generics, deferred annotations, template strings, free-threaded support), and the community converging on clear conventions (structured logging via structlog, Trusted Publishing for PyPI, layered security pipelines). The most actionable insight across all ten areas: **the cost of not modernizing has grown sharply** — teams using the 2025 default stack (uv, ruff, pyright, pytest) report dramatically faster CI pipelines, simpler configuration, and fewer tool-related friction points than those maintaining legacy setups. For new projects, the path is clear. For existing projects, migration guides from Poetry/pip to uv and from Black/Flake8 to ruff are well-documented and low-risk.
